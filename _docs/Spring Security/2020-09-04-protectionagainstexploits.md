---
title: Protection Against Exploits (WebFlux)
category: Spring Security
order: 27
permalink: /Spring%20Security/webfluxsecurity/protectionagainstexploits
description: 웹플럭스 기반 어플리케이션에서 스프링 시큐리티로 취약점 공격을 방어하는 방법을 설명합니다. 공식 문서에 있는 "Protection Against Exploits in Reactive Applications" 챕터를 한국어로 번역한 문서입니다.
image: ./../../images/springsecurity/spring-security.png
lastmod: 2020-09-20T23:18:12+09:00
comments: true
originalRefName: 스프링 시큐리티
originalRefLink: https://docs.spring.io/spring-security/site/docs/5.3.2.RELEASE/reference/html5/#protection-against-exploits
---

### 목차:

- [24.1. Cross Site Request Forgery (CSRF) for WebFlux Environments](#241-cross-site-request-forgery-csrf-for-webflux-environments)
  + [24.1.1. Using Spring Security CSRF Protection](#2411-using-spring-security-csrf-protection)
    * [Use proper HTTP verbs](#use-proper-http-verbs)
    * [Configure CSRF Protection](#configure-csrf-protection)
    * [Include the CSRF Token](#include-the-csrf-token)
  + [24.1.2. CSRF Considerations](#2412-csrf-considerations)
    * [Logging Out](#logging-out)
    * [CSRF and Session Timeouts](#csrf-and-session-timeouts)
    * [Multipart (file upload)](#multipart-file-upload)
    * [HiddenHttpMethodFilter](#hiddenhttpmethodfilter)
- [24.2. Security HTTP Response Headers](#242-security-http-response-headers)
  + [24.2.1. Default Security Headers](#2421-default-security-headers)
  + [24.2.2. Cache Control](#2422-cache-control)
  + [24.2.3. Content Type Options](#2423-content-type-options)
  + [24.2.4. HTTP Strict Transport Security (HSTS)](#2424-http-strict-transport-security-hsts)
  + [24.2.5. X-Frame-Options](#2425-x-frame-options)
  + [24.2.6. X-XSS-Protection](#2426-x-xss-protection)
  + [24.2.7. Content Security Policy (CSP)](#2427-content-security-policy-csp)
  + [24.2.8. Referrer Policy](#2428-referrer-policy)
  + [24.2.9. Feature Policy](#2429-feature-policy)
  + [24.2.10. Clear Site Data](#24210-clear-site-data)
- [24.3. HTTP](#243-http)
  + [24.3.1. Redirect to HTTPS](#2431-redirect-to-https)
  + [24.3.2. Strict Transport Security](#2432-strict-transport-security)
  + [24.3.3. Proxy Server Configuration](#2433-proxy-server-configuration)

---

## 24.1. Cross Site Request Forgery (CSRF) for WebFlux Environments

이번 섹션에선 웹플럭스 환경에서 스프링 시큐리티로 [사이트간 요청 위조(Cross Site Request Forgery, CSRF)](../features#521-cross-site-request-forgery-csrf)를 방어하는 방법을 설명한다.

### 24.1.1. Using Spring Security CSRF Protection

스프링 시큐리티로 CSRF를 방어하는 방법은 크게 다음 단계로 나뉜다:

- [올바른 HTTP verb를 사용한다](#use-proper-http-verbs)
- [CSRF 방어를 설정한다](#configure-csrf-protection)
- [CSRF 토큰을 추가한다](#include-the-csrf-token)

#### Use proper HTTP verbs

CSRF 공격을 방어하려면 가장 먼저 만드려는 웹사이트에서 올바른 HTTP verb를 사용해야 한다. 자세한 내용은 [Safe Methods Must be Idempotent](../features#safe-methods-must-be-idempotent)에서 다루고 있다

#### Configure CSRF Protection

그다음엔 어플리케이션에 스프링 시큐리티의 CSRF 방어 기능을 설정해야 한다. 스프링 시큐리티에선 CSRF 방어를 기본적으로 활성화하지만, 아마 일부 설정을 커스텀해야 할 거다. 아래는 일반적으로 커스텀하는 설정들이다.

##### Custom CsrfTokenRepository

기본적으로 스프링 시큐리티는 `WebSessionServerCsrfTokenRepository`로 CSRF 토큰을 `WebSession`에 저장한다. 하지만 커스텀 `ServerCsrfTokenRepository`를 설정하고 싶을 때도 있을 것이다. 예를 들어 [자바스크립트 기반 어플리케이션을 지원](#automatic-inclusion)하려면 쿠키에 `CsrfToken`을 저장해야 한다.

기본적으로 `CookieServerCsrfTokenRepository`는 `XSRF-TOKEN`이란 쿠키를 저장하고, `X-XSRF-TOKEN` 헤더나 `_csrf` 파라미터에서 토큰을 읽어들인다. 이 디폴트 값들은 [AngularJS](https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection)에서 따온 값이다.

자바 설정으로 `CookieCsrfTokenRepository`를 설정하는 방법은 다음과 같다:

**Example 166. Store CSRF Token in a Cookie with Java Configuration**

```java
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
    return http.build();
}
```

> 이 샘플에선 `cookieHttpOnly=false`를 명시했다. 자바스크립트(i.e. AngularJS)에서 읽어가려면 이렇게 명시해야 한다. 자바스크립트에서 직접 쿠키를 읽어야할 필요가 없다면 보안을 위해 `cookieHttpOnly=false`를 생략하는 게 좋다 (이대신 `new CookieServerCsrfTokenRepository()`를 사용해서).

##### Disable CSRF Protection

CSRF 방어는 기본적으로 활성화된다. 하지만 [굳이 CSRF를 방어할 필요가 없는 어플리케이션](../features#when-to-use-csrf-protection)을 만든다면 간단히 비활성화할 수 있다.

아래 자바 설정은 CSRF 방어를 비활성화한다.

**Example 167. Disable CSRF Java Configuration**

```java
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -> csrf.disable()))
    return http.build();
}
```

#### Include the CSRF Token

[동기화 토큰 패턴](../features#synchronizer-token-pattern)으로 CSRF 공격을 방어하려면 HTTP 요청에 실제 CSRF 토큰을 추가해야 한다. 토큰은 반드시 폼 파라미터, HTTP 헤더같이 브라우저가 HTTP 요청에 자동으로 추가하지 않는 곳에 넣어야 한다.

스프링 시큐리티의 [CsrfWebFilter](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html)는 `ServerWebExchange` 속성에 `org.springframework.security.web.server.csrf.CsrfToken`이란 이름으로 [Mono](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html)를 추가한다. 따라서 어떻게 뷰를 렌더링하든지, [폼](#csrftoken-request-attribute)이나 [메타 태그](#meta-tags)에서 `Mono<CsrfToken>`으로 토큰에 접근할 수 있다.

<span id="webflux-csrf-include-subscribe"></span>사용하는 뷰 기술이 `Mono<CsrfToken>`을 간단히 구독하는 방법을 제공하지 않을 때 사용하는 일반적인 패턴은, 스프링의 `@ControllerAdvice`를 써서 `CsrfToken`을 직접 노출하는 것이다. 예를 들어 다음 코드는 스프링 시큐리티의 [CsrfRequestDataValueProcessor](#automatic-csrf-token-inclusion)에서 사용하는 디폴트 속성 이름(`_csrf`)에 `CsrfToken`을 담아, hidden 인풋에 CSRF 토큰이 자동으로 추가되게 만든다.

**Example 168. `CsrfToken` as `@ModelAttribute`**

```java
@ControllerAdvice
public class SecurityControllerAdvice {
    @ModelAttribute
    Mono<CsrfToken> csrfToken(ServerWebExchange exchange) {
        Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName());
        return csrfToken.doOnSuccess(token -> exchange.getAttributes()
                .put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
    }
}
```

다행히 타임리프는 [통합](#automatic-csrf-token-inclusion) 기능을 제공하므로 설정을 추가하지 않아도 된다.

##### Form URL Encoded

HTML 폼을 사용한다면 hidden 인풋에 CSRF 토큰을 추가해야 한다. 예를 들어 다음과 같은 HTML을 렌더링할 수 있다:

**Example 169. CSRF Token HTML**

```html
<input type="hidden"
    name="_csrf"
    value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
```

이제부터는 CSRF 토큰을 hidden 인풋에 추가하는 여러 가지 방법을 설명한다.

###### Automatic CSRF Token Inclusion

스프링 시큐리티의 CSRF 기능은 [CsrfRequestDataValueProcessor](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html)로 스프링의 [RequestDataValueProcessor](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html)와 통합할 수 있다. `CsrfRequestDataValueProcessor`를 사용하려면, `Mono<CsrfToken>`을 구독하고 `CsrfToken`을 [DEFAULT_CSRF_ATTR_NAME](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME)과 동일한 이름으로 [속성에 추가](#webflux-csrf-include-subscribe)해야 한다.

타임리프는 이를 위한 보일러플레이트를 모두 [지원](https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor)하며, `RequestDataValueProcessor`를 통합해 unsafe HTTP 메소드(i.e. post)를 사용하는 폼은 자동으로 실제 CSRF 토큰을 추가해 준다.

###### CsrfToken Request Attribute

[다른 방법](#include-the-csrf-token)으로 요청에 실제 CSRF 토큰을 추가할 수 없다면, `ServerWebExchange`의 `org.springframework.security.web.server.csrf.CsrfToken` 속성에 `Mono<CsrfToken>`이 [들어있다는 점](#include-the-csrf-token)을 활용하면 된다.

아래 타임리프 예제는 `_csrf`라는 이름의 속성에 `CsrfToken`을 [추가](#webflux-csrf-include-subscribe)했다고 가정한다.

**Example 170. CSRF Token in Form with Request Attribute**

```html
<form th:action="@{/logout}"
    method="post">
<input type="submit"
    value="Log out" />
<input type="hidden"
    th:name="${_csrf.parameterName}"
    th:value="${_csrf.token}"/>
</form>
```

##### Ajax and JSON Requests

JSON을 사용한다면 HTTP 파라미터로 CSRF 토큰을 제출할 수 없다. 대신 HTTP 헤더를 활용할 수 있다.

아래 섹션에선 자바스크립트 기반 어플리케이션에서 HTTP 요청 헤더에 CSRF 토큰을 추가하는 여러 가지 방법을 설명한다.

###### Automatic Inclusion

간단하게 CSRF 토큰을 쿠키에 저장하도록 [설정](#custom-csrftokenrepository)할 수 있다. CSRF 토큰을 쿠키에 저장하면 [AngularJS](https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection)같은 자바스크립트 프레임워크는 자동으로 HTTP 요청 헤더에 실제 CSRF 토큰을 추가한다.

###### Meta tags

[쿠키에 CSRF 토큰을 추가](#automatic-csrf-token-inclusion)하는 대신 사용할 수 있는 또 다른 패턴은 `meta` 태그를 사용하는 것이다. 다음과 같은 HTML이 있다면:

**Example 171. CSRF meta tag HTML**

```html
<html>
<head>
    <meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
    <meta name="_csrf_header" content="X-CSRF-TOKEN"/>
    <!-- ... -->
</head>
<!-- ... -->
```

메타 태그에 CSRF 토큰을 추가하고 나면 자바스크립트 코드에서 이 메타 태그를 읽어 헤더에 CSRF 토큰을 추가할 수 있다. jQuery를 사용한다면 다음과 같이 작성할 수 있다:

**Example 172. AJAX send CSRF Token**

```javascript
$(function () {
    var token = $("meta[name='_csrf']").attr("content");
    var header = $("meta[name='_csrf_header']").attr("content");
    $(document).ajaxSend(function(e, xhr, options) {
        xhr.setRequestHeader(header, token);
    });
});
```

아래 타임리프 예제는 `_csrf`라는 이름의 속성에 `CsrfToken`을 [추가](#webflux-csrf-include-subscribe)했다고 가정한다.

**Example 173. CSRF meta tag JSP**

```html
<html>
<head>
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <!-- default header name is X-CSRF-TOKEN -->
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <!-- ... -->
</head>
<!-- ... -->
```

### 24.1.2. CSRF Considerations

CSRF 공격을 방어하려면 특별히 고려해야 할 몇 가지가 있다. 이번 섹션에선 웹플럭스 환경에서 주의할 사항을 설명한다. 일반적인 주의사항은 [CSRF Considerations](../features#csrf-considerations)를 참고하라.

#### Logging In

로그인을 위조하지 못하게 막으려면 [로그인 요청을 CSRF 공격으로부터 보호](../features#logging-in)해야 한다. 스프링 시큐리티는 웹플럭스에서 CSRF 로그인 공격을 방어할 수 있는 기능을 지원한다.

#### Logging Out

로그아웃을 위조하지 못하게 막으려면 [로그아웃 요청을 CSRF 공격으로부터 보호](../features#logging-in)해야 한다. 기본적으로 스프링 시큐리티의 `LogoutWebFilter`는 HTTP POST 요청만 처리한다. CSRF 토큰을 검사하므로 악의적으로 다른 사용자의 로그아웃을 위조하지 못한다.

로그아웃을 구현하는 가장 쉬운 방법은 폼을 사용하는 것이다. 링크가 꼭 있어야 한다면 자바스크립트로 POST 요청을 수행하는 링크를 만들면 된다 (hidden 폼으로). 자바스크립트가 비활성화된 브라우저에선 POST 요청을 수행하는 로그아웃 컨펌 페이지로 사용자를 이동시키는 링크를 만들 수 있다.

로그아웃에서 HTTP GET을 꼭 써야 한다면 그럴 순 있지만, 일반적으로 권장하는 방법이 아니란 점을 알아둬라. 예를 들어 아래 자바 설정은 `/logout` URL의 모든 HTTP 메소드 요청에서 로그아웃을 수행한다.

**Example 174. Log out with HTTP GET**

```java
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .logout(logout -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
    return http.build();
}
```

#### CSRF and Session Timeouts

기본적으로 스프링 시큐리티에선 CSRF 토큰을 `WebSession`에 저장한다. 따라서 세션이 만료되면 검증할 CSRF 토큰이 없는 상황이 발생할 수 있다.

세션 타임아웃을 해결하는 [일반적인 방법](../features#csrf-and-session-timeouts)은 앞에서 이미 설명했다. 이번에는 웹플럭스에서 CSRF 타임아웃에 대응하는 방법을 설명한다.

간단하게 CSRF 토큰을 쿠키에 저장하도록 바꿀 수 있다. 자세한 내용은 [Custom CsrfTokenRepository](#custom-csrftokenrepository) 섹션을 참고하라.

#### Multipart (file upload)

CSRF 공격으로부터 멀티파트 요청을 (파일 업로드) 보호하려고 할 땐 [닭이 먼저인가, 달걀이 먼저인가](https://en.wikipedia.org/wiki/Chicken_or_the_egg)하는 문제와 맞닥뜨릴 수 있다고 [앞에서 이미 언급](../features#multipart-file-upload)했었다. 이번 섹션에선 웹플럭스 어플리케이션에서 [body](#place-csrf-token-in-the-body)와 [url](#include-csrf-token-in-url)에 CSRF 토큰을 추가하는 방법을 설명한다.

> 스프링에서 멀티파트 폼을 사용하는 방법은 스프링 레퍼런스의 [Multipart Data](https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart) 섹션에서 자세히 설명한다.

##### Place CSRF Token in the Body

CSRF 토큰을 바디에 두면 생길 수 있는 상황은 [앞에서 이미 설명했다](../features#place-csrf-token-in-the-body).

웹플럭스 어플리케이션에선 다음과 같이 설정할 수 있다:

**Example 175. Enable obtaining CSRF token from multipart/form-data**

```java
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -> csrf.tokenFromMultipartDataEnabled(true))
    return http.build();
}
```

##### Include CSRF Token in URL

CSRF 토큰을 URL에 두면 생길 수 있는 상황은 [앞에서 이미 설명했다](../features#place-csrf-token-in-the-body). `ServerHttpRequest` [요청 속성](#include-the-csrf-token)에 `CsrfToken`이 들어있으므로, 이를 사용해서 `action`을 만들 수 있다. 다음은 타임리프를 사용한 예시이다.

**Example 176. CSRF Token in Action**

```html
<form method="post"
    th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
    enctype="multipart/form-data">
```

#### HiddenHttpMethodFilter

HTTP 메소드 재정의는 [앞에서 이미 설명했다](../features#hiddenhttpmethodfilter).

스프링 웹플럭스 어플리케이션에선 [HiddenHttpMethodFilter](https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html)를 사용해서 HTTP 메소드를 재정의한다.

---

## 24.2. Security HTTP Response Headers

[보안 HTTP 응답 헤더](../features#522-security-http-response-headers)는 웹 어플리케이션을 보호할 때 사용하는 헤더다. 이번 섹션에선 웹플럭스 기반 어플리케이션에서 사용할 수 있는 보안 HTTP 응답 헤더를 설명한다.

### 24.2.1. Default Security Headers

스프링 시큐리티는 기본적인 보안을 위한 [HTTP 응답 헤더의 디폴트 셋](../features#default-security-headers)을 제공한다. 모든 헤더가 다 좋은 관행이라고는 하지만, 그렇다고 해서 모든 클라이언트가 다 헤더를 사용하는 것은 아니므로 추가적인 테스트가 필요하다.

특정 헤더를 커스텀할 수도 있다. 예를 들어 [X-Frame-Options](#2425-x-frame-options)에선 `SAMEORIGIN`을 지정하돼, 다른 헤더는 모두 디폴트 값을 사용하고 싶을 수도 있다.

아래처럼 자바 설정으로 쉽게 변경할 수 있다:

**Example 177. Customize Default Security Headers with Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .frameOptions(frameOptions -> frameOptions
                .mode(Mode.SAMEORIGIN)
            )
        );
    return http.build();
}
```

디폴트 값을 사용하는 대신 사용할 헤더만 명시하고 싶다면 디폴트 설정을 비활성화할 수 있다. 다음은 자바 설정을 사용한 예시이다:

**Example 178. Disable HTTP Security Response Headers**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers.disable());
    return http.build();
}
```

### 24.2.2. Cache Control

스프링 시큐리티는 디폴트로 [Cache Control](../features#cache-control) 헤더를 추가한다.

하지만 특정 응답을 캐시하고 싶다면 어플리케이션에서 원하는 곳에서 [ServerHttpResponse](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html)에 헤더를 추가해 스프링 시큐리티의 헤더 셋을 재정의하면 된다. CSS, 자바스크립트, 이미지 등을 적절히 캐시해야 할 때 유용하다.

스프링 웹플럭스를 사용한다면 설정으로 캐시를 관리할 수 있다. 자세한 방법은 스프링 레퍼런스 문서의 [스태틱 리소스](https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-static-resources) 섹션을 참고해라.

필요하다면 스프링 시큐리티의 cache control HTTP 응답 헤더를 비활성화할 수 있다.

**Example 179. Cache Control Disabled**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .cache(cache -> cache.disable())
        );
    return http.build();
}
```

### 24.2.3. Content Type Options

스프링 시큐리티는 디폴트로 [Content-Type](../features#content-type-options) 헤더를 추가한다. 하지만 자바 설정으로 비활성화할 수 있다:

**Example 180. Content Type Options Disabled with Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable())
        );
    return http.build();
}
```

### 24.2.4. HTTP Strict Transport Security (HSTS)

스프링 시큐리티는 디폴트로 [Strict Transport Security](../features#http-strict-transport-security-hsts) 헤더를 추가한다. 하지만 헤더 내용을 직접 커스텀할 수도 있다. 예를 들어 다음 예제는 자바 설정으로 사용할 HSTS를 지정한다:

**Example 181. Strict Transport Security with Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .hsts(hsts -> hsts
                .includeSubdomains(true)
                .preload(true)
                .maxAge(Duration.ofDays(365))
            )
        );
    return http.build();
}
```

### 24.2.5. X-Frame-Options

스프링 시큐리티는 기본적으로 [X-Frame-Options](../features#x-frame-options)를 사용해서 아이프레임 내부 렌더링을 비활성화한다.

다음 코드는 자바 설정으로 프레임 옵션을 SAMEORIGIN으로 커스텀한다:

**Example 182. X-Frame-Options: SAMEORIGIN**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .frameOptions(frameOptions -> frameOptions
                .mode(SAMEORIGIN)
            )
        );
    return http.build();
}
```

### 24.2.6. X-XSS-Protection

스프링 시큐리티는 기본적으로 [X-XSS-Protection 헤더](../features#x-xss-protection)를 사용해서 브라우저에게 reflected XSS 공격을 막도록 지시한다. 다음 자바 설정으로 `X-XSS-Protection`을 비활성화할 수도 있다:

**Example 183. X-XSS-Protection Customization**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .xssProtection(xssProtection -> xssProtection.disable())
        );
    return http.build();
}
```

### 24.2.7. Content Security Policy (CSP)

[컨텐츠 보안 정책](../features#content-security-policy-csp)은 어플리케이션에 따라 다르므로 디폴트라는 게 불가능하며, 스프링 시큐리티는 디폴트로 관련 헤더를 추가하지 않는다. 보안 정책을 운영하거나 보호 중인 리소스를 모니터링하려면 어플리케이션에서 직접 지정해야 한다.

예를 들어 다음과 같은 보안 정책을 사용한다면:

**Example 184. Content Security Policy Example**

```http
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
```

아래에 있는 자바 설정으로 CSP 헤더를 활성화할수 있다:

**Example 185. Content Security Policy**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .contentSecurityPolicy(policy -> policy
                .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
            )
        );
    return http.build();
}
```

CSP `report-only` 헤더를 사용하려면 아래 자바 설정을 사용해라:

**Example 186. Content Security Policy Report Only**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .contentSecurityPolicy(policy -> policy
                .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                .reportOnly()
            )
        );
    return http.build();
}
```

### 24.2.8. Referrer Policy

스프링 시큐리티는 디폴트로 [Referrer Policy](../features#referrer-policy) 헤더를 추가하지 않는다. 아래와 같은 자바 설정으로 Referrer Policy 헤더를 추가할 수 있다:

**Example 187. Referrer Policy Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .referrerPolicy(referrer -> referrer
                .policy(ReferrerPolicy.SAME_ORIGIN)
            )
        );
    return http.build();
}
```

### 24.2.9. Feature Policy

스프링 시큐리티는 디폴트로 [Feature Policy](../features#feature-policy) 헤더를 추가하지 않는다. 다음 `Feature-Policy` 헤더는:

**Example 188. Feature-Policy Example**

```http
Feature-Policy: geolocation 'self'
```

아래 자바 설정으로 활성화할 수 있다:

**Example 189. Feature-Policy Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -> headers
            .featurePolicy("geolocation 'self'")
        );
    return http.build();
}
```

### 24.2.10. Clear Site Data

스프링 시큐리티는 디폴트로 [Clear-Site-Data](../features#clear-site-data) 헤더를 추가하지 않는다. 아래 Clear-Site-Data 헤더는:

**Example 190. Clear-Site-Data Example**

```
Clear-Site-Data: "cache", "cookies"
```

아래 자바 설정을 사용해서 로그아웃 시 전송할 수 있다:

**Example 191. Clear-Site-Data Java Configuration**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
    ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);
    ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);
    DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

    http
        // ...
        .logout()
            .logoutHandler(logoutHandler);
    return http.build();
}
```

---

## 24.3. HTTP

모든 HTTP 통신은 [TLS](../features#523-http)로 보호해야 한다.

아래에선 웹플럭스 어플리케이션에서 HTTPS를 사용할 때 활용할만한 기능을 설명한다.

### 24.3.1. Redirect to HTTPS

스프링 시큐리티는 클라이언트가 HTTPS가 아닌 HTTP로 보낸 요청을 HTTPS로 리다이렉트하게 설정할 수 있다.

예를 들어 아래 자바 설정은 모든 HTTP 요청을 HTTPS로 리다이렉트한다:

**Example 192. Redirect to HTTPS**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .redirectToHttps(withDefaults());
    return http.build();
}
```

이 설정은 if문으로 감싸서 프로덕션 레벨에서만 활성화하도록 만들 수 있다. 또는 프로덕션에서만 사용하는 요청 프로퍼티를 찾아 활성화할 수도 있다. 예를 들어 프로덕션 환경에서 `X-Forwarded-Proto`라는 헤더를 추가한다면 아래 자바 코드를 사용할 수 있다:

**Example 193. Redirect to HTTPS when X-Forwarded**

```java
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .redirectToHttps(redirect -> redirect
            .httpsRedirectWhen(e -> e.getRequest().getHeaders().containsKey("X-Forwarded-Proto"))
        );
    return http.build();
}
```

### 24.3.2. Strict Transport Security

스프링 시큐리티는 [Strict Transport Security](../protectionagainstexploits/#1424-http-strict-transport-security-hsts)를 지원하며 디폴트로 활성화돼 있다.

### 24.3.3. Proxy Server Configuration

스프링 시큐리티는 [프록시 서버와의 통합](../features#proxy-server-configuration)을 지원한다.